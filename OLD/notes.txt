A FAIRE:
- envoyer status correct apres la derniere pipeline (et garde $? en memoire qq part...)
- tous les messages d'erreur dans partie parsing
- tout clean a la norme (surtout parsing...)
- revoir builtins (gros pb avec le fork et **env)




#v3  final [normalement]

typedef struct s_cmd_lst {
	char	**cmds;
	char	**files;
	int		*file_type;  -> 1 pour in, 2 out, 3 out append
	int		file_amt;   -> met au cas ou file name vide ( "" )
	void	*next;
}			t_cmd_lst;



#idee 2 -> bcp mieux

typedef struct s_parsed_lst {
	char	**cmds;
	char	*in_file;               // pour << : faire pdt le parsing (plus simple comme ca)
	char	*out_file;              // et >>   : ajouter un int out_type ?   //note pour check_fd : outfile 1st ?
	int		in_fd;
	int		out_fd;
	int		out_mode;
	void	*next;
}			t_parsed_lst;

// pense a gerer les redirections multipes ! >out1 >>out2

	EXEMPLE : 
echo  $USER    " text   "    | < Makefile   cat | "grep .c | head -2" | ls '-l ' > outfile

	lst1: 
cmds = {"echo", "asadanow", " text   ", 0};
fd_in = NULL;
fd_out = NULL;
out_mode = 0;

	lst2:
cmds = {"cat", 0};
fd_in = "Makefile";
fd_out = NULL;
out_mode = 0;

	lst3:
cmds = {"grep .c | head -2", 0};
fd_in = NULL;
fd_out = NULL;
out_mode = 0;

	lst4:
cmds = {"ls", "-l ", 0};
fd_in = NULL;
fd_out = "outfile";
out_mode = 0;


PARSING:

0- fct qui check format (quote non ferme et pipe au debut/fin)
1- split_1 par |  (sauf si quotes)
2- while (**split_1)
	1- cree liste
	2- split_2 par espaces (sauf si quotes)  <- et remplace les $ si pas dans single quote?
	3- si "<", la str suivante va dans fd_in (si pas de suivante, message d'erreur et free tout)
	4- si ">", la str suivante va dans fd_out (______)
	3-4bis  si "<<" rempli un fd tmp avec GNL, et ">>" out_mode = 1;
	5- update split_2 pour enlever les <> et leurs fd_in/out, resultat va dans cmds (et premier element dans cmd)
3- envoi **head de parsed_list dans partie exec








#idee 1    nul pas pratique

typedef struct	s_parsed {
	char**	cmd;
	char**	cmd_full;
	char**	fd_in;
	char**	fd_out;
	int		count;
}			t_parsed;

	EXEMPLE : 
echo  $USER    "text   "    | < Makefile cat | "grep .c | head -2" | ls '-l ' > outfile

cmd =  {"echo",
		"cat",
		"grep .c | head -2",
		"ls"}

cmd_full =	{"echo asadanow text ",
			 "cat",
			 "grep .c | head -2",
			 "ls -l "}

fd_in = {NULL,
		 "Makefile",
		 NULL,
		 NULL}

fd_out = {NULL,
		  NULL,
		  NULL,
		  "outfile"}

count = 4


+ $? à filtré aussi, jsp comment